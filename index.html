<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Рубрики и подкатегории</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="styles.css" />
</head>
<body>

<header class="page-head">
  <h1>Выбор рубрик Kwork</h1>
  <p class="muted">Отметь категории, подкатегории и атрибуты. Выбор категории включает все её подкатегории, а выбор подкатегории — все её атрибуты.</p>
</header>

<main class="container">
  <div id="rubrics-grid" class="grid"></div>
</main>

<footer class="footer">
  <button id="doneBtn" class="btn primary">✅ Готово</button>
  <div id="result" class="result"></div>
</footer>

<script>
/* ========= Пример данных (можешь подставить свой JSON) ========= */
const rubrics = {
  "5": {
    "id": 5,
    "CATID": 5,
    "name": "Тексты и переводы",
    "cats": [
      {
        "id": "303",
        "CATID": "303",
        "name": "ИИ-тексты",
        "attributes": {
          "4178791": { "id": 4178791, "title": "ИИ-генерация статей" },
          "4178794": { "id": 4178794, "title": "ИИ-обработка текстов" }
        }
      },
      {
        "id": "304",
        "CATID": "304",
        "name": "Копирайтинг",
        "attributes": {
          "4178801": { "id": 4178801, "title": "Статьи для блогов" },
          "4178802": { "id": 4178802, "title": "SEO-тексты" }
        }
      }
    ]
  },
  "11": {
    "id": 11,
    "CATID": 11,
    "name": "Разработка и IT",
    "cats": [
      {
        "id": "79",
        "CATID": "79",
        "name": "Верстка",
        "attributes": {
          "224": { "id": 224, "title": "Верстка по макету" },
          "226": { "id": 226, "title": "Доработка и адаптация" }
        }
      },
      {
        "id": "80",
        "CATID": "80",
        "name": "Десктоп программирование",
        "attributes": {
          "975": { "id": 975, "title": "Программы на заказ" },
          "976": { "id": 976, "title": "Макросы для Office" }
        }
      }
    ]
  }
};

/* ========= Рендер ========= */
function renderRubrics(data, grid) {
  for (const topKey in data) {
    const top = data[topKey];

    const card = document.createElement('details');   // ⬅ вместо <section>
    card.className = 'card';
    card.open = false; // чтобы изначально был закрыт

    const header = document.createElement('summary'); // ⬅ вместо <header>
    header.className = 'card-head';

    const topLabel = document.createElement('label');
    topLabel.className = 'check';
    const topCb = document.createElement('input');
    topCb.type = 'checkbox';
    topCb.className = 'top-checkbox';
    topCb.value = top.id;
    topCb.dataset.topId = String(top.id);
    const topText = document.createElement('span');
    topText.textContent = top.name;

    topLabel.appendChild(topCb);
    topLabel.appendChild(topText);
    header.appendChild(topLabel);
    card.appendChild(header);

    const body = document.createElement('div');
    body.className = 'card-body';


    if (Array.isArray(top.cats)) {
      top.cats.forEach(cat => {
        const details = document.createElement('details');
        details.className = 'cat';
        details.open = false;

        const sum = document.createElement('summary');

        const catLabel = document.createElement('label');
        catLabel.className = 'check';
        const catCb = document.createElement('input');
        catCb.type = 'checkbox';
        catCb.className = 'cat-checkbox';
        catCb.value = cat.id;
        catCb.dataset.topId = String(top.id);
        catCb.dataset.catId = String(cat.id);
        const catText = document.createElement('span');
        catText.textContent = cat.name;

        catLabel.appendChild(catCb);
        catLabel.appendChild(catText);
        sum.appendChild(catLabel);
        details.appendChild(sum);

        const attrsWrap = document.createElement('div');
        attrsWrap.className = 'attrs';

        // атрибуты могут быть объектом или массивом — нормализуем
        const attrs = Array.isArray(cat.attributes)
          ? cat.attributes
          : (cat.attributes ? Object.values(cat.attributes) : []);

        attrs.forEach(a => {
          const aLabel = document.createElement('label');
          aLabel.className = 'check';
          const aCb = document.createElement('input');
          aCb.type = 'checkbox';
          aCb.className = 'attr-checkbox';
          aCb.value = a.id;
          aCb.dataset.topId = String(top.id);
          aCb.dataset.catId = String(cat.id);
          aCb.dataset.attrId = String(a.id);
          const aText = document.createElement('span');
          aText.textContent = a.title;

          aLabel.appendChild(aCb);
          aLabel.appendChild(aText);
          attrsWrap.appendChild(aLabel);

          // изменение атрибута => обновить подкатегорию и топ
          aCb.addEventListener('change', () => {
            updateCatState(details);
            updateTopState(card);
          });
        });

        details.appendChild(attrsWrap);
        body.appendChild(details);

        // изменение подкатегории => выбрать/снять все её атрибуты
        catCb.addEventListener('change', () => {
          setChildrenChecked(attrsWrap.querySelectorAll('.attr-checkbox'), catCb.checked);
          updateCatState(details);   // выставит indeterminate=false если все переключили одинаково
          updateTopState(card);
        });
      });
    }

    card.appendChild(body);

    // изменение топ-категории => выбрать/снять все подкатегории и их атрибуты
    topCb.addEventListener('change', () => {
      const catCbs = card.querySelectorAll('.cat-checkbox');
      const attrCbs = card.querySelectorAll('.attr-checkbox');
      setChildrenChecked(catCbs, topCb.checked);
      setChildrenChecked(attrCbs, topCb.checked);
      // сбрасываем неопределённость, раз всё синхронно
      topCb.indeterminate = false;
      // и у каждой подкатегории тоже:
      card.querySelectorAll('.cat').forEach(catDetails => {
        const catBox = catDetails.querySelector('.cat-checkbox');
        if (catBox) catBox.indeterminate = false;
      });
    });

    grid.appendChild(card);
  }
}

/* ========= Утилиты состояний ========= */
function setChildrenChecked(nodeList, checked) {
  nodeList.forEach(cb => { cb.checked = checked; });
}

function updateCatState(catDetailsEl) {
  const catCb = catDetailsEl.querySelector('.cat-checkbox');
  const attrs = catDetailsEl.querySelectorAll('.attr-checkbox');
  const total = attrs.length;
  const checked = catDetailsEl.querySelectorAll('.attr-checkbox:checked').length;

  if (total === 0) {
    // у подкатегории нет атрибутов — состояние управляется напрямую пользователем
    return;
  }

  catCb.checked = (checked === total);
  catCb.indeterminate = (checked > 0 && checked < total);
}

function updateTopState(cardEl) {
  const topCb = cardEl.querySelector('.top-checkbox');
  const catBoxes = cardEl.querySelectorAll('.cat-checkbox');
  const totalCats = catBoxes.length;

  if (totalCats === 0) {
    topCb.indeterminate = false;
    return;
  }

  let checkedCats = 0;
  let hasIndeterminateChild = false;

  catBoxes.forEach(cb => {
    if (cb.checked) checkedCats++;
    if (cb.indeterminate) hasIndeterminateChild = true;
  });

  topCb.checked = (checkedCats === totalCats);
  topCb.indeterminate = (!topCb.checked) && (checkedCats > 0 || hasIndeterminateChild);
}

/* ========= Сбор выбранного ========= */
function collectSelection() {
  // собираем по структуре: top -> cats -> attrs
  const result = [];

  document.querySelectorAll('.card').forEach(card => {
    const topCb = card.querySelector('.top-checkbox');
    const topName = card.querySelector('.card-head .check span')?.textContent?.trim() || '';
    const top = {
      id: Number(topCb.value),
      name: topName,
      cats: []
    };

    card.querySelectorAll('.cat').forEach(cat => {
      const catCb = cat.querySelector('.cat-checkbox');
      const catName = cat.querySelector('summary .check span')?.textContent?.trim() || '';
      // включаем подкатегорию, если она отмечена ИЛИ если в ней отмечены атрибуты
      const attrsChecked = cat.querySelectorAll('.attr-checkbox:checked');
      if (catCb.checked || attrsChecked.length > 0) {
        const catObj = {
          id: isNaN(Number(catCb.value)) ? catCb.value : Number(catCb.value),
          name: catName,
          attrs: []
        };
        attrsChecked.forEach(a => {
          const label = a.parentElement.querySelector('span');
          catObj.attrs.push({
            id: isNaN(Number(a.value)) ? a.value : Number(a.value),
            title: label ? label.textContent.trim() : String(a.value)
          });
        });
        top.cats.push(catObj);
      }
    });

    if (topCb.checked || top.cats.length > 0) {
      result.push(top);
    }
  });

  return result;
}

/* ========= Отправка боту (простой POST к Bot API) ========= */
/* ========= Отправка данных в бота ========= */
function sendToTelegram(selected) {
  // Передаем JSON с выбранными категориями
  const text = {
    action: "rubrics_selected",
    payload: selected
  };

  Telegram.WebApp.sendData(JSON.stringify(text));
  return true; // чтобы код выше понимал что "отправка ок"
}


/* ========= Инициализация ========= */
renderRubrics(rubrics, document.getElementById('rubrics-grid'));

/* ========= Кнопка "Готово" ========= */
document.getElementById('doneBtn').addEventListener('click', async () => {
  const selected = collectSelection();
  const out = document.getElementById('result');
  out.textContent = selected.length ? 'Отправляю выбранные…' : 'Ничего не выбрано.';

  try {
    const ok = await sendToTelegram(selected);
    out.textContent = ok ? '✅ Отправлено боту.' : '❌ Не удалось отправить боту.';
    // для отладки:
    console.log('SELECTED:', selected);
  } catch (e) {
    out.textContent = '❌ Ошибка отправки.';
  }
});
</script>

</body>
</html>
